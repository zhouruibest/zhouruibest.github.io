# 数组指针

## 数组指针与指针数组

数组指针：指的是一个指针，只不过这个指针指向了一个数组
```go
    var arr [5]int = [5]int{1,2,3,4,5};
    var p *[5]int = &arr;
    fmt.Println(p);//0xc00006a030
    //此时p称为是数组arr的指针
    //此时如果通过p访问数组元素是 (*p)[2]，结果是3
```

指针数组：指的是一个数组，这个数组里面装满了指针。
```go
    var arr1 [5]int = [5]int{1,2,3,4,5};
    var arr2 [5]int = [5]int{6,7,8,9,0};
    var p1 *[5]int = &arr1;
    var p2 *[5]int = &arr2;
    var pArr [2]*[5]int = [2]*[5]int{p1,p2};
    fmt.Println(pArr);//[0xc00006a030, 0xc00006a060]
    //此时pArr称为是指针数组
    //此时如果通过pArr访问数组元素是 (*pArr[0])[2],结果是3
```

## 地址相同、类型不同问题

在go语言中，内存地址相同并不意味着其表示的数据或者数据类型就完全相同。
```go
    var arr [5]int = [5]int{1,2,3,4,5};
    p1,p2 := &arr,&arr[0];
    fmt.Println(p1);        //&[1,2,3,4,5] 整个数组的内存地址
    fmt.Println(p2);        //0xc0000180c0 数组第一个元素的内存地址
    fmt.Printf("%T",p1);    //*[5]int    数组指针
    fmt.Printf("%T",p2);    //*int        指针
```

## *号可以不写问题

在go语言中通过指针去访问指针所对应的地址处的值时，*允许不写。而这个规定又会催生一个由于go运算符优先级问题而催生的指针访问问题。

```go
var arr [5]int = [5]int{1,2,3,4,5};
p := &arr;
fmt.Println(*p[0]);
// 乍一看这段代码并无任何问题。因为p是数组指针，*p就是数组本身，而*p[0]自然就是数组的第一个元素.但是事与愿违，代码的运行结果是一个错误！
// 这是因为在go语言中*寻址运算符和[]中括号运算符的优先级是不同的！
// []中括号是初等运算符, *寻址运算符是单目运算符
// 初等运算符的优先级是大于单目运算符的，因此先参与计算的是p[0];
// p[0]其实就是数组的第一个元素，就是数字1
// 数字1必然是int类型，而不是一个地址，因此针对数字1使用*寻址运算符自然也就发生了错误。
// 解决问题的办法很简单，就是添加一个小括号就可以了。
// 即：(*p)[0]
// 仅对访问下标时，*寻址运算符允许不写！
```

# 切片指针

### 切片名

在go语言中切片名本身就是一个地址。因此通过切片名加下标的方式访问切片元素原本就是指针访问的一种表现。
```go
    var slice []int = []int{1,2,3,4,5};
    fmt.Printf("%p\n", slice);//0xc000012346;
    fmt.Println(slice[0]);
```
### 二重指针

因为切片名本身已经是一个指针了，如果再对切片名取地址，那么得到的就是一个地址的地址、指针的指针，即二重地址(二级地址、二重指针、二级指针)
```go
p := &slice;
fmt.Printf("%p\n", p);//0xc000012446;
```

**面对一重指针时*寻址运算符在go语言中是省略不写的，但是在二重与二重以上的指针参与运算的时候，*寻址运算符则是必不可少的。**


```go
fmt.Println(p);            //0xc0000aa362     相当于传统c中的*p 
fmt.Println(*p);           //0xc0000ac141    相当于传统c中的**p
fmt.Println(p[0]);         //           相当于传统c中的(*p)[0]
fmt.Println((*p)[0]);      //1                相当于传统c中的(**p)[0]
```

## 切片指针作为函数参数

切片指针作为函数参数传入函数内部时，不论是修改还是追加都能保证函数内的操作影响到函数外部.而不像切片作为函数参数传入函数内部，只有修改会影响外部，而追加则无法对外部造成影响。
```go
func sliceParam(tempSlice []int){
    tempSlice = append(tempSlice, 4,5,6);
}
func sliceParamPointer(tempSlicePointer *[]int){
    *tempSlicePointer = append(*tempSlicePointer,4,5,6);
}
func main() {
    slice := []int{1,2,3};
    sliceParam(slice);
    fmt.Println(slice);//[1,2,3]
    sliceParamPointer(&slice);
    fmt.Println(slice);//[1,2,3,4,5,6]
}
```
## new为切片指针分配内存空间

```go
var s []int;
s = make([]int,0);//这一句写不写无所谓
s = append(s, 1,2,3);
fmt.Println(s)

不过go语言总切片比较特殊，是可以在内容追加后进行“内存变更”的. 换句话说，哪怕不使用make对s切片进行长度的分配也无所谓。但是对于切片指针来说则是完全不同。
```

```go
var p *[]int;
p = new([]int);//这一句必须写
*p = append(*p,1,2,3);
fmt.Println(*p);
// 当使用切片指针的时候，go语言规定指针必须被分配内存才能使用，否则空指针是没办法进行寻址赋值操作的。go语言使用new来对指针进行分配内存空间，p=new([]int)表示让p指向一个int类型切片数据的地址。
```

