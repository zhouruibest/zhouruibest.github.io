

2. Redis分布式锁怎么获取

3. 如何防止缓存穿透？如何加锁？可否用本地锁

4. cpu报表了怎么办？

5. Memory报表了怎么办

6. 死锁问题

7. go gc优化

8. 分库分表怎么实现，怎么处理共享表的？

9. 简历亮点： 别人没做的我在做； 项目的规模，业务的背景，项目的效果，个人的成绩 3～5个项目


# mysql 
## InnoDB系统自增row_id
如果你创建的 InnoDB 表没有指定主键，那么 InnoDB 会给你创建一个不可见的，长度为 6 个字节的 row_id。InnoDB 维护了一个全局的 dict_sys.row_id 值，所有无主键的 InnoDB 表，每插入一行数据，都将当前的 dict_sys.row_id 值作为要插入数据的 row_id，然后把 dict_sys.row_id 的值加 1。

实际上，在代码实现时 row_id 是一个长度为8字节的无符号长整型 (bigint unsigned)。但是，InnoDB 在设计时，给 row_id 留的只是 6 个字节的长度，这样写到数据表中时只放了最后 6 个字节，所以 row_id 能写到数据表中的值，就有两个特征：

row_id 写入表中的值范围，是从 0 到 248-1；
当 dict_sys.row_id=2^48时，如果再有插入数据的行为要来申请 row_id，拿到以后再取最后 6 个字节的话就是 0。

## mysql数据库cpu飙升怎么办？
排查：
- 用top命令观察，确定是mysqld导致的还是其他原因
- 如果是mysqld导致的，show processlist，查看session情况，确定是不是有消耗资源的sql在运行
- 找出消耗高的sql，看看执行计划是否准确，索引是否缺失，数据量是否太大
处理：
- kill掉这些线程（同时观察cpu使用率是否下降）
- 进行相应的调整（比如说加索引，修改sql，改内存参数等）
- 重新跑这些sql

## 自增主键用完了怎么办？

> “这问题没遇到过，因为自增主键一般用int类型，一般达不到最大值，我们就分库分表了，所以不曾遇见过！”

在mysql中，unsigned int的范围如下 （0～4294967295），4字节。一旦自增id达到最大值，此时数据继续插入是会报一个主键冲突异常如下所示

```sh
Duplicate entry '4294967295' for key 'PRIMARY'
```

那解决方法也是很简单的，将Int类型改为BigInt类型，BigInt的范围(0~18446744073709551615), 将自增ID设为BigInt类型，你是不用考虑自增ID达到最大值这个问题.

进一步提问，如何修改数据类型？

方案一：直接修改
在5.6+开始，mysql支持在线修改数据库表，在修改表的过程中，对绝大部分操作，原表可读，也可以写。那对于修改列的数据类型这种操作，原表还能写么？

答：对于修改数据类型这种操作，是不支持并发的DML操作！也就是说，如果你直接使用ALTER这样的语句在线修改表数据结构，会导致这张表无法进行更新类操作(DELETE、UPDATE、DELETE)。

因此，直接ALTER是不行滴！

方案二：借助第三方工具

1. pt-online-schema-chang，简称pt-osc
- 创建一个新的表，表结构为修改后的数据表，用于从源数据表向新表中导入数据。
- 创建触发器，用于记录从拷贝数据开始之后，对源数据表继续进行数据修改的操作记录下来，用于数据拷贝结束后，执行这些操作，保证数据不会丢失。
- 拷贝数据，从源数据表中拷贝数据到新表中。
- ename源数据表为old表，把新表rename为源表名，并将old表删除。
- 删除触发器。
2. GitHub正式宣布以开源的方式发布的工具，名为gh-ost

## 自增id的生成时机
生成自增 ID 的过程是在 MySQL 的存储引擎层进行的。对于使用 InnoDB 存储引擎的表，MySQL 会使用自增锁（auto-increment locking）机制来保证生成的自增 ID 的唯一性。在插入数据时，InnoDB 会获取自增锁，生成一个新的自增 ID，并将其分配给插入的数据行。然后，在事务提交或回滚时，自增锁会被释放，下一个插入操作可以继续生成下一个自增 ID。

需要注意的是，自增 ID 的生成是在存储引擎层完成的，并不是 MySQL 服务器层的功能。因此，不同的存储引擎可能会在自增 ID 的生成和管理上有所不同。例如，MyISAM 存储引擎使用表级锁来生成自增 ID，而 InnoDB 存储引擎使用自增锁来生成自增 ID。

总结起来，MySQL 的主键自增 ID 是在插入数据的阶段由存储引擎生成的，确保了生成的自增 ID 的唯一性和顺序性。这一机制简化了开发者对主键的管理，并提供了高效的自增 ID 生成方式。

# redis

## 击穿问题

何为击穿？ 大量请求发过来，查询redis没有命中，然后请求又打到mysql上去了

解决方案1：

1. 请求发过来
2. 查询redis(没有命中)
3. 加锁同步查询数据库：（1）加锁，获取到锁才可以执行 （2）再查询一次redis，查询到的话跳到第4步，否则到第3步 （3）查询数据库 （4）将查询结果放到redis （5）释放锁（6）返回

- 这个锁叫做：双重查询锁
- 是否需要加分布式锁而不是上面的线程锁？ 可以加，那样的话只有一个请求会最终请求到mysql；也可以加，这样的话集群有多少台机器，就最多有多少请求击穿。因此不要过度设计，用线程锁解决即可

解决方案2:

热数据永不过期

冷数据设置过期时间

## 缓存雪崩
原因：
1. 一批数据集中过期，导致大量不同请求达到了数据库
2. redis挂掉了

解决方案：
1. 在解决击穿问题的基础上，给数据加上随机过期时间
2. 哨兵模式；高可用部署

## 缓存穿透

大量请求，在redis查不到，在数据库也查不到。可能是有人恶意请求，比如请求一些不存在的资源

解决：
1. 参数校验，比如id为负数了
2. 缓存空对象，记得设置失效时间
3. bloom过滤器。数据库没有的数据放到里面（黑名单模式）

# consul

## Consul 的负载均衡是如何实现的？

当一个服务需要访问其他服务时，它会向 Consul 的 Agent 发送一个服务发现请求，Agent 会返回一个可用的服务地址列表，并根据负载均衡算法选择一个地址进行访问。
Consul 支持多种负载均衡算法，包括轮询、随机、加权轮询、加权随机等

## Consul 的故障恢复是如何实现的？

Consul 的故障恢复是通过 Agent 进程实现的。
当一个服务的健康状态发生变化时，Agent 会将服务的状态信息发送到 Consul 的 Server 上，并通知其他服务进行故障恢复。
如果一个服务无法访问其他服务，它会向 Consul 的 Agent 发送一个故障恢复请求，Agent 会返回一个可用的服务地址列表，并根据负载均衡算法选择一个地址进行访问。

## Consul 的分布式 KV 存储是如何实现的？

Consul 的分布式 KV 存储是通过 Raft 算法实现的。
当一个服务需要存储一些配置信息时，它会向 Consul 的 Agent 发送一个 KV 存储请求，Agent 会将配置信息存储在本地，并将信息发送到 Consul 的 Server 上。
当服务需要读取配置信息时，它会向 Consul 的 Agent 发送一个 KV 读取请求，Agent 会返回存储在本地的配置信息。

## Consul 的事件通知是如何实现的？


Consul 的事件通知是通过 Watcher 机制实现的。
当一个服务需要监听某个事件时，它会向 Consul 的 Agent 发送一个 Watcher 请求，Agent 会将请求发送到 Consul 的 Server 上，并返回一个 Watcher ID。
当事件发生时，Consul 的 Server 会将事件信息发送到所有注册了 Watcher的服务，服务可以根据事件信息进行相应的处理


# 分布式

## 常见的分布式 ID 实现

1. UUID

虽然都说 UUID 是全球唯一，具备我们前面提到的要求中的第一点，但是很显然不具备全局递增，这种分布式 ID 可读性很差，如果说只是用来记录日志或者不需要人去理解的场景是可以用，但是不适合我们这里说的业务数据的唯一标识。而且这种无序的 UUID 如果作为主键会很严重影响性能。

2. Redis
Redis 有个 incr 的命令，这个命令是能保证原子递增的，在某种程度上也是可以生成全局 ID，不过使用 Redis 有两个问题：

- 不美观，虽然说我们需要的是一个全局 ID，但是 incr 命令是从 1 开始的整型，所以会导致全局 ID 的长度不一致，虽然说也可以用来标识唯一业务数据，但是某些场景也缺少可读性，因为不携带日期信息；
- 依赖 Redis 的高可用，因为 Redis 是基于内存的，为了保证 ID 的不丢失所以需要对 Redis 进行持久化

3. 变形的数据库自增 ID；
设置自增主键时，步长不一致。（该方法不推荐）

4. 推特雪花算法

算法是推特开源的分布式 ID 生成算法，这个算法提供了一个标准的思路，很多公司都参考这个算法做了自己的实现，比较有名的是美团的 Leaf

雪花算法的思想是化整为零，将分布式 ID 的生成分散到每个机房和机器上，采用一个 64 位 long 类型的的结构来表示一个 ID，64 的结构如下所示，第一位符号位 0，然后是 41 位的时间戳（毫秒），接下来的 10 位是机房加机器，最后的 12 位是序列号。

也就是说一毫秒可以取出2^12=4096个
- 生成结果趋势递增，不一定是单调递增
- 因为有时间戳，所以满足自增的要求，同时也具备一定的可读性；
- 化整为零每个服务在各自的机器上可以直接生成唯一 ID，只需要配置好机房和机器编号即可；
- 长度可以根据业务自行调整；
- 缺点是依赖机器的时钟，如果说机器的时钟有问题（时钟回拨问题），会导致生成的 ID 可能会重复，这个需要控制；

时钟回拨的解决方案：

（1）抛异常 （2）发现时钟回拨问题收，等待一下 （3）优化雪花算法，将10位的机器+机房的前三位在拆分出来，做时钟序列，一旦发现时钟回拨了，就给这三位加一

5. 美团的 Leaf——雪花算法的变形；
