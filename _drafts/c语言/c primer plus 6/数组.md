# 声明只读的数组
```c
const int days[MONTHS] = {31,28,31,30,31,30,31,31,30,31,30,31};

// 告诉编译器，该函数不能修改ar指向的数组中的内容
int sum(const int ar[], int n); /* 函数原型 */
int sum(const int ar[], int n)  /* 函数定义 */
{
    ...
}
```

当初始化列表中的值少于数组元素个数时，编译器会把剩余的元素都初始化为0。也就是说，如果不初始化数组，数组元素和未初始化的普通变量一样，其中储存的都是垃圾值；但是，如果部分初始化数组，剩余的元素就会被初始化为0。

# 制定初始化器

```c
int arr[6] = {[5] = 212}; // 把arr[5]初始化为212
int days[MONTHS] = { 31, 28, [4] = 31, 30, 31, [1]= 29 };
int staff[] = {1, [6] = 4, 9, 10}; // 数组大小为9.没有指定值的元素为0.可以认为初始化之前有一次memset
```

# 数组赋值

C 不允许把数组作为一个单元赋给另一个数组，除初始化以外也不允许使用花括号列表的形式赋值。

# 指定数组的大小

在C99标准之前，声明数组时只能在方括号中使用整型常量表达式。所谓整型常量表达式，是由整型常量构成的表达式。**sizeof表达式被视为整型常量，但是（与C++不同）const值不是**。

# 多维数组的初始化

```c
const float rain[YEARS][MONTHS] = // const表示存储在其中的数据，不能修改
{
    { 4.3, 4.3, 4.3, 3.0, 2.0, 1.2, 0.2, 0.2, 0.4, 2.4, 3.5, 6.6 },
    { 8.5, 8.2, 1.2, 1.6, 2.4, 0.0, 5.2, 0.9, 0.3, 0.9, 1.4, 7.3 },
    { 9.1, 8.5, 6.7, 4.3, 2.1, 0.8, 0.2, 0.2, 1.1, 2.3, 6.1, 8.4 },
    { 7.2, 9.9, 8.4, 3.3, 1.2, 0.8, 0.4, 0.0, 0.6, 1.7, 4.3, 6.2 },
    { 7.6, 5.6, 3.8, 2.8, 3.8, 0.2, 0.0, 0.0, 0.0, 1.3, 2.6, 5.2 }
};
```

初始化时也可省略内部的花括号，只保留最外面的一对花括号。只要保证初始化的数值个数正确，初始化的效果与上面相同。但是如果初始化的数值不够，则按照先后顺序逐行初始化，直到用完所有的值。后面没有值初始化的元素被统一初始化为0。

# 关于const

执行const的指针不能用于改变值
```c
const int days[DAYS] = {1, 2, 3}; //
days[1] = 3;// 编译错误

int months[MONTHS] = {1,2,3}
const int * pi = months; // * pi==> 是指针， const int是指向的类型
*pi = 4; // 编译错误
pi++; // 改变pi的值， 可以

double rates[5] = {1,2,3,4,5};
double * const p2 = rates; // * const p2 ==> 是不能改变值的指针变量，地址指向的值是一个double

// 把非const指针赋给const指针没问题，前提是只进行一级解引用：
const int **pp2;
int *p1;
const int n = 13;
pp2 = &p1; // 允许，但是这导致const限定符失效（不能通过*pp2修改它所指向的内容）
*pp2 = &n; // 有效，两者都声明为const，但是这将导致p1指向n（*pp2已被修改）
*p1 = 10;//有效，但是这将改变n的值（但是根据第3行代码，不能修改n的值）

```

C标准规定，使用非`const`标识符（如，`mult_arry(int * ar)`的形参ar）修改`const`数据（如，`const int * locked`）导致的结果是未定义的。

# C const和C++ const
C和C++中const的用法很相似，但是并不完全相同。
区别之一是，C++允许在声明数组大小时使用const整数，而C却不允许。
区别之二是，C++的指针赋值检查更严格

```c
const int y;
const int * p2 = &y;
int * p1;
p1 = p2; // C++中不允许这样做，但是C可能只给出警告
```

# 多维数组
```c
int (* pz)[2]; // pz指向一个内含两个int类型值的数组, 为什么要用小括号，因为[]的优先级大于*
int * pax[2]; // pax是一个内含两个指针元素的数组，每个元素都指
向int的指针

```

# 多维数组和函数

```c
int sum4d(int ar[][12][20][30], int rows);
等价于
int sum4d(int (*ar)[12][20][30], int rows); // ar是一个指针

// 第1对方括号只用于表明这是一个指针，而其他的方括号则用于描述指针所指向数据对象的类型。
```

# const、数组和指针

## const修饰普通变量
将一个变量声明为只读，也就是常量，无法被修改。
```c
const int constant = 10;
int const constant = 10;//也可以将const放在int后面
```
## const修饰数组
使用const来修饰数组声明了一个数组常量，是对数组里面数据的一种保护，当试图修改一个被const修饰的数组内容时，编译时会产生错误。
```c
const int days[5] = {1,2,3,4,5}; //int const days[5]一样
days[0] = 6; //Cannot assign to variable 'days' with const-qualified type 'const int [5]'

```

## const修饰指针
const修饰指针创建了一个指针常量，但是const的位置会导致这个指针常量有不同的含义。
```c
    int days[5] = {1,2,3,4,5};
    const int *p1;//const修饰的是int，表示p1指向的变量值不可改变,指针本身可以改变
    //p1指向的值为常量
    p1 = days;
    *p1 = 6;//报错，不允许修改指针指向的值。Read-only variable is not assignable
    p1[1] = 7;//报错，不允许修改
    days[0] = 6;//允许，days不是常量
    p1++;//合法，p1这个指针本身是可以修改的，这里让其指向days的第二个元素

    int * const p2 = days;//const修饰的是p2，表示p2这个指针本身是无法修改的，但是其指向的值是可以修改的
    //这里p2本身是常量，因此声明p2的时候就要初始化，否则后面无法对p2进行初始化
    *p2 = 10;//合法，p2指向的值可以修改
    p2 = &days[1];//不合法，报错，p2是常量，因此想要修改指针的值使其指向days[1]不合法。
    //Cannot assign to variable 'p2' with const-qualified type 'int *const'
```