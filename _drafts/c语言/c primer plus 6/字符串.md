# 初始化
```c
char　words[MAXLENGTH]　=　"I　am　a　string　in　an　array.";
const char * pt1= "Somethingispointingatme.";

// 从ANSI C标准起，如果字符串字面量之间没有间隔，或者用空白字符分割，C会将其视为串联起来的字符串字面量， 例如

char greeting[50] = "hello, and"" how are"  " you"
" today";

等价于

char greeting[50] = "hello, and how are you todya";

// 在指定数组大小时，要确保数组的元素个数至少比字符串长度多1（为了容纳空字符）所有未被使用的元素都被自动初始化为\0
```


# 数组和指针
```c
const char * pt1 = "Something is pointing at me.";
const char ar1[] = "Something is pointing at me.";
```
数组形式和指针形式有何不同？以上面的声明为例，数组形式（ar1[]）在计算机的内存中分配为一个含29个元素的数组（每个元素对应一个字符，还加上一个末尾的空字符'\0'），每个元素被初始化为字符串字面量对应的字符。通常，**字符串都作为可执行文件的一部分储存在数据段中**。当把程序载入内存时，也载入了程序中的字符串。字符串储存在静态存储区（static memory）中。但是，程序在开始运行时才会为该数组分配内存。此时，才**将字符串拷贝到数组中**。注意，此时字符串有两个副本.**一个是在静态内存中的字符串字面量，另一个是储存在ar1数组中的字符串。**

此后，编译器便把数组名ar1识别为该数组首元素地址（&ar1[0]）的别名。这里关键要理解，在数组形式中，**ar1是地址常量,不能更改ar1**。如果改变了ar1，则意味着改变了数组的存储位置（即地址）。可以进行类似ar1+1这样的操作，标识数组的下一个元素。但是不允许进行++ar1这样的操作。

指针形式（*pt1）也使得编译器为字符串在静态存储区预留29个元素的空间。

字符串字面量被视为`const`数据。由于`pt1`指向这个`const`数据，所以应该把pt1声明为指向`const`数据的指针。这意味着不能用pt1改变它所指向的数据，但是仍然可以改变pt1的值（即，pt1指向的位置）。如果把一个字符串字面量拷贝给一个数组，就可以随意改变数据，除非把数组声明为`const`。

总之，初始化数组把静态存储区的字符串拷贝到数组中，而初始化指针只把字符串的地址拷贝给指针。程序清单11.3演示了这一点