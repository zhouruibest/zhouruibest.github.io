# 零拷贝的使用

1. Netty
2. Kafka
3. Nginx

# 一个普通IO发生4次上下文切换和4次数据拷贝

程序开始使用系统调用read告诉操作系统要从磁盘文件中读取数据，它首先从用户态切换到内核态，这个切换是有花费的，操作系统需要保存用户态的状态，一些寄存器的地址等，等read系统调用完成后返回，程序又需要从内核态切换到用户态，把保存的用户态的状态恢复，所以一次系统调用需要两次的用户态/内核态的切换。同样，把文件的内容写入到socket的时候，程序调用write系统调用，又进行了两次用户态/内核态的切换。

从操作的数据来看，这个数据还被拷贝了四次。在read系统调用的时候，DMA方式从磁盘拷贝到内核缓冲区，又通过CPU拷贝从内核缓冲区拷贝到用户的程序缓冲区，这里发生了两次拷贝。在写入socket的时候，数据先从用户程序缓冲区写入到socket缓冲区，又通过DMA方式从socket缓冲区写入到网卡。数据拷贝也发生了四次

# DMA

DMA(Direct Memory Access，直接存储器访问) 是计算机科学中的一种内存访问技术。它允许某些电脑内部的硬件子系统（电脑外设），可以独立地直接读写系统内存，允许不同速度的硬件设备来沟通，而不需要依于中央处理器的大量中断负载。

# mmap通过用户空间和内核空间映射实现3次拷贝和4次上下文切换

通过mmap系统调用，将用户空间的虚拟地址和内核空间的虚拟地址映射成同一个物理地址这样可以减少内核空间和内核空间的数据拷贝。

通过mmap系统调用发起IO读取，DMA将磁盘数据写入到内核缓冲区，此时mmap系统调用就返回了。程序调用write系统调用，CPU将内核缓冲区的数据写入到socket缓冲区，DMA又将数据从socket缓冲区谢瑞到网卡。

可以看到，mmap+write方式有两次系统调用，发生四次用户态/内核态的切换，三次数据拷贝。

相对传统的IO方式，减少了一次数据拷贝，但是应该还有优化的空间。

# 等一下，不是说sendfile零拷贝吗？为什么还是要 2 次拷贝？
 
首先我们说零拷贝，是**从操作系统的角度**来说的。因为内核缓冲区之间，没有数据是重复的（只有 kernel buffer 有一份数据，sendFile 2.1 版本实际上有 2 份数据，算不上零拷贝）。例如我们刚开始的例子，内核缓存区和 Socket 缓冲区的数据就是重复的。

而零拷贝不仅仅带来更少的数据复制，还能带来其他的性能优势，
1. 更少的上下文切换
2. 更少的 CPU 缓存伪共享
3. 无 CPU 校验和计算。

# mmap 和 sendFile 的区别

1、mmap 适合小数据量读写，sendFile 适合大文件传输。
2、mmap 需要 4 次上下文切换，3 次数据拷贝；sendFile 需要2次上下文切换，2次数据拷贝。
3、sendFile 可以利用 DMA 方式，减少 CPU 拷贝，mmap 则不能（必须从内核拷贝到 Socket 缓冲区）。

# sendFile的局限性

sendFile只适用于将数据从文件拷贝到套接字上，限定了它的使用范围。有的场景下，需要将数据从一个套接字直接拷贝到另一个套接字，例如代理服务器，这种场景下，sendFile无法满足需求。

Linux 2.6.30版本之前，源和目的只能有一个是管道(pipe), 自2.6.31开始, 源和目的只要保证有一个是就行。

当然，如果我们处理的源和目的不是管道的话，我们可以先建立一个管道，这样就可以使用splice系统调用来实现零拷贝了。

但是，如果每次都创建一个管道，你会发现每次都会多一次系统调用，也就是两次用户态/内核态的切换，所以你如果频繁的拷贝数据，那么可以建立一个管道池就像pjf给Go的标准库提供的一个补丁一样，利用pipe pool对Go语言中的splice做了优化。

tee系统调用用来在两个管道中拷贝数据。

vmsplice系统调用pipe指向的内核缓冲区和用户程序的缓冲区之间的数据拷贝。

# 其他

https://colobu.com/2022/11/19/zero-copy-and-how-to-use-it-in-go/


Linux v4.14 MSG_ZEROCOPY

Linux 4.5 copy_file_range
